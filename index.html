<!doctype html>
<html lang="et">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Metsa-kaamera — puuliigi, sortimendi ja rikete tuvastus (Automaat + Manuaal)</title>
  <style>
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial;margin:0;display:flex;flex-direction:column;align-items:center;gap:10px;padding:12px;background:#f0f2f5}
    .stage{position:relative;width:100%;max-width:900px;background:#000;color:#fff;border-radius:10px;overflow:hidden}
    video{width:100%;height:auto;display:block;background:#000}
    canvas.overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button,select,input[type=file],input[type=number]{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#fff;color:#000}
    label{display:flex;gap:6px;align-items:center}
    .status{font-size:14px}
    .hint{font-size:13px;color:#444;max-width:900px}
    .log-area{width:100%;max-width:900px;height:220px;overflow:auto;background:#111;color:#0f0;padding:8px;border-radius:6px;font-family:monospace}
    .info-panel{width:100%;max-width:900px;background:#fff;color:#111;padding:10px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.08)}
    .info-row{display:flex;gap:12px;flex-wrap:wrap}
    .info-item{min-width:160px}
  </style>
</head>
<body>
  <h2>Metsa-kaamera — puuliigi, sortimendi ja rikete tuvastus</h2>
  <div class="stage">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay" class="overlay"></canvas>
  </div>

  <div class="controls">
    <button id="startBtn">Alusta</button>
    <button id="stopBtn" disabled>Peata</button>
    <label>Kaamera: <select id="camSelect"></select></label>
    <label>Liikumise tundlikkus: <input id="sensitivity" type="range" min="0.5" max="10" step="0.1" value="2"><span id="sensVal">2.0</span></label>
    <label>Referentsobjekt pikkus (cm): <input id="refCm" type="number" step="1" value="100" style="width:90px"></label>
  </div>

  <div class="controls">
    <label>Lae puuliigi mudel (TFJS): <input id="speciesModel" type="file" accept=".json,.bin"></label>
    <label>Lae rikete mudel (TFJS): <input id="damageModel" type="file" accept=".json,.bin"></label>
    <label>Autotuvastuse intervall (s): <input id="autoInterval" type="number" min="1" value="5" style="width:70px"></label>
  </div>

  <div class="controls">
    <button id="captureBtn">Pildista & analüüsi (manuaal)</button>
    <button id="toggleAutoBtn">Lülita automaatne tuvastus: Väljas</button>
    <button id="downloadLogBtn">Laadi alla log (.txt)</button>
  </div>

  <div class="status" id="status">Staatus: ootab käivitamist</div>
  <div class="hint">Märkused: laadida saab TFJS formaadis(mudel.json + weight sharded failid). Auto-tuvastus jookseb perioodiliselt isegi kui kaamera seisab. Logi salvestub lihtsas inimloetavas tekstivormingus nagu soovisid.</div>

  <div class="info-panel" id="infoPanel">
    <div><strong>Viimane tuvastus</strong></div>
    <div class="info-row">
      <div class="info-item">SORTIMENT: <span id="outSortiment">-</span></div>
      <div class="info-item">PUULIIK: <span id="outSpecies">-</span></div>
      <div class="info-item">KAHJUSTUSED: <span id="outDamage">-</span></div>
      <div class="info-item">UMBKAUDNE VÄÄRTUS: <span id="outValue">-</span></div>
    </div>
  </div>

  <div class="log-area" id="logArea">Logi tühi — tuvastused ilmuvad siia.</div>

  <!-- TensorFlow.js ja COCO-SSD CDN-id -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

  <script>
    // DOM
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const camSelect = document.getElementById('camSelect');
    const sensitivity = document.getElementById('sensitivity');
    const sensVal = document.getElementById('sensVal');
    const captureBtn = document.getElementById('captureBtn');
    const downloadLogBtn = document.getElementById('downloadLogBtn');
    const logArea = document.getElementById('logArea');
    const speciesModelInput = document.getElementById('speciesModel');
    const damageModelInput = document.getElementById('damageModel');
    const refCmInput = document.getElementById('refCm');
    const autoIntervalInput = document.getElementById('autoInterval');
    const toggleAutoBtn = document.getElementById('toggleAutoBtn');

    const outSortiment = document.getElementById('outSortiment');
    const outSpecies = document.getElementById('outSpecies');
    const outDamage = document.getElementById('outDamage');
    const outValue = document.getElementById('outValue');

    let stream = null;
    let cocoModel = null; // general detector
    let speciesModel = null;
    let damageModel = null;
    let animationId = null;
    let prevImageData = null;
    let logTextLines = [];
    let autoTimer = null;
    let autoEnabled = false;

    let motionThresholdRatio = parseFloat(sensitivity.value);
    sensVal.textContent = motionThresholdRatio.toFixed(1);
    sensitivity.addEventListener('input', () => { motionThresholdRatio = parseFloat(sensitivity.value); sensVal.textContent = motionThresholdRatio.toFixed(1); });

    async function listCameras(){
      try{
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === 'videoinput');
        camSelect.innerHTML = '';
        cams.forEach((c, i) => { const opt=document.createElement('option'); opt.value=c.deviceId; opt.text=c.label||`Kaamera ${i+1}`; camSelect.appendChild(opt); });
      }catch(e){ console.warn('Seadmete loetelu ebaõnnestus', e); }
    }

    async function startCamera(){
      stopCamera();
      const deviceId = camSelect.value || undefined;
      const constraints = { video: { deviceId: deviceId ? { exact: deviceId } : undefined, facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
      try{
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await video.play();
        overlay.width = video.videoWidth; overlay.height = video.videoHeight; prevImageData = null;
        status('Kaamera käivitatud. Laadin COCO-SSD...');
        if(!cocoModel){ cocoModel = await cocoSsd.load(); status('COCO-SSD laetud.'); } else status('COCO-SSD juba laetud.');
        startBtn.disabled = true; stopBtn.disabled = false; startLoop();
        // kui automaatne on sisse lülitatud, alusta timerit
        if(autoEnabled) enableAutoTimer();
      }catch(err){ console.error(err); status('Kaamera viga: ' + err.message); }
    }

    function stopCamera(){ if(animationId) cancelAnimationFrame(animationId); animationId=null; if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } startBtn.disabled=false; stopBtn.disabled=true; status('Peatatatud.'); ctx.clearRect(0,0,overlay.width, overlay.height); disableAutoTimer(); }
    function status(t){ statusEl.textContent = 'Staatus: ' + t; }

    // liikumise tuvastus (saame sellest loobuda kui tahame automaatset tuvastust alati)
    function detectMotion(imageData){ if(!prevImageData){ prevImageData = imageData; return false; } const curr=imageData.data, prev=prevImageData.data; let diffCount=0; for(let i=0;i<curr.length;i+=24){ const gray1=(curr[i]+curr[i+1]+curr[i+2])/3; const gray0=(prev[i]+prev[i+1]+prev[i+2])/3; if(Math.abs(gray1-gray0)>20) diffCount++; } prevImageData=imageData; const sampled=(imageData.width*imageData.height)/9; const ratio=diffCount/sampled; const threshold=0.01*motionThresholdRatio; return ratio>threshold; }

    // laadime TFJS mudeli browserFiles abil
    async function loadTFJSModelFromFile(input){ if(!input.files || input.files.length===0) return null; const files = Array.from(input.files); try{ const m = await tf.loadGraphModel(tf.io.browserFiles(files)); return m; }catch(e){ try{ const m2 = await tf.loadLayersModel(tf.io.browserFiles(files)); return m2; }catch(e2){ console.error('Mudeli laadimine ebaõnnestus', e2); return null; } } }

    speciesModelInput.addEventListener('change', async ()=>{ status('Laen puuliigi mudelit...'); speciesModel = await loadTFJSModelFromFile(speciesModelInput); if(speciesModel) status('Puuliigi mudel laetud.'); else status('Puuliigi mudeli laadimine ebaõnnestus.'); });
    damageModelInput.addEventListener('change', async ()=>{ status('Laen rikete mudelit...'); damageModel = await loadTFJSModelFromFile(damageModelInput); if(damageModel) status('Rikete mudel laetud.'); else status('Rikete mudeli laadimine ebaõnnestus.'); });

    // käsitsi pildistamine
    captureBtn.addEventListener('click', async ()=>{ if(!video.srcObject){ status('Alusta kaamerat enne pildistamist'); return; } captureBtn.disabled=true; try{ await analyseFrame(true); }finally{ captureBtn.disabled=false; } });

    // auto tuvastuse lüliti
    toggleAutoBtn.addEventListener('click', ()=>{ autoEnabled = !autoEnabled; toggleAutoBtn.textContent = `Lülita automaatne tuvastus: ${autoEnabled? 'Sees':'Väljas'}`; if(autoEnabled) enableAutoTimer(); else disableAutoTimer(); });

    function enableAutoTimer(){ disableAutoTimer(); const s = Math.max(1, Number(autoIntervalInput.value)||5); autoTimer = setInterval(()=>{ if(video.srcObject) analyseFrame(false); }, s*1000); status('Automaatne tuvastus sisse (iga ' + s + 's)'); }
    function disableAutoTimer(){ if(autoTimer){ clearInterval(autoTimer); autoTimer=null; status('Automaatne tuvastus välja'); } }

    // log allalaadimine .txt kujul
    downloadLogBtn.addEventListener('click', ()=>{
      if(logTextLines.length===0){ alert('Log tühi.'); return; }
      const blob = new Blob([logTextLines.join('

')], {type:'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download = `metsatuvastus_log_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'_')}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // põhifunktsioon: analüüsi kaadrit; parameter forceDraw - kui manuaalne, siis alati joonista ja logi
    async function analyseFrame(forceDraw=false){
      const off = document.createElement('canvas'); const w = video.videoWidth, h = video.videoHeight; off.width=w; off.height=h; const offCtx = off.getContext('2d'); offCtx.drawImage(video,0,0,w,h);
      const imageData = offCtx.getImageData(0,0,w,h);

      // detect objects with coco to find candidates; fallback to segmentation-like regions
      status('Analüüsin kaadrit — otsin objekte...');
      let detections = [];
      try{ detections = await cocoModel.detect(video); }catch(e){ console.warn('COCO detect viga', e); }
      let regions = [];
      const candidates = detections.filter(d=>d.score>0.35 && d.class!=='person');
      if(candidates.length>0){ regions = candidates.map(c=>({bbox:c.bbox, score:c.score, class:c.class})); }
      else {
        // lihtne tumedamate komponentide segmentatsioon
        const gray = new Uint8ClampedArray(w*h);
        for(let i=0;i<w*h;i++){ const r=imageData.data[i*4], g=imageData.data[i*4+1], b=imageData.data[i*4+2]; gray[i]=0.3*r+0.59*g+0.11*b; }
        const meanGray = gray.reduce((a,b)=>a+b,0)/(w*h);
        const mask = new Uint8ClampedArray(w*h);
        for(let i=0;i<w*h;i++) mask[i] = gray[i] < meanGray*0.95 ? 1:0;
        const seen = new Uint8Array(w*h);
        function bboxFromComponent(sx,sy){ let minx=sx,maxx=sx,miny=sy,maxy=sy; const stack=[[sx,sy]]; seen[sy*w+sx]=1; while(stack.length){ const [x,y]=stack.pop(); for(const dx of [-1,0,1]) for(const dy of [-1,0,1]){ const nx=x+dx, ny=y+dy; if(nx<0||ny<0||nx>=w||ny>=h) continue; const idx=ny*w+nx; if(mask[idx] && !seen[idx]){ seen[idx]=1; stack.push([nx,ny]); if(nx<minx)minx=nx; if(nx>maxx)maxx=nx; if(ny<miny)miny=ny; if(ny>maxy)maxy=ny; } } } return {x:minx,y:miny,w:(maxx-minx),h:(maxy-miny)}; }
        for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ const idx=y*w+x; if(mask[idx] && !seen[idx]){ const bb=bboxFromComponent(x,y); if(bb.w*bb.h > (w*h*0.002)) regions.push({bbox:[bb.x,bb.y,bb.w,bb.h], score:0.5, class:'pile_candidate'}); } } }
      }

      // kui pole regioone ja ei ole forceDraw, siis kontrollime liikumist: kui liikumist ei ole ja ei ole automaatseid/force -> lõpetame
      if(regions.length===0 && !forceDraw){ const motion = detectMotion(imageData); if(!motion){ status('Ei leitud objekte ega liikumist.'); return; } }

      // joonistame overlay ja loome kokkuvõtte iga regiooni kohta
      ctx.clearRect(0,0,overlay.width,overlay.height);
      const refCm = parseFloat(refCmInput.value) || 100;
      let lastSummary = {sortiment:'-', species:'-', damage:'-', value:'-'};

      const frameResults = [];
      for(const r of regions){
        const [x,y,wbox,hbox] = r.bbox.map(v=>Math.round(v)); if(wbox<=0||hbox<=0) continue;
        const crop = offCtx.getImageData(x,y,wbox,hbox);
        // draw box
        ctx.strokeStyle = 'lime'; ctx.lineWidth = Math.max(2, Math.round(overlay.width/300)); ctx.strokeRect(x,y,wbox,hbox);

        // species predict
        let species = {class:'unknown', score:0};
        if(speciesModel){ try{ const imgTensor = tf.browser.fromPixels(crop).resizeBilinear([224,224]).toFloat().expandDims(0).div(255.0); const preds = await speciesModel.predict(imgTensor); const arr = preds.data ? await preds.data() : await preds.array(); const maxIdx = arr.indexOf(Math.max(...arr)); species = {class:`class_${maxIdx}`, score:arr[maxIdx]}; imgTensor.dispose(); if(preds.dispose) preds.dispose(); }catch(e){ console.error('species predict err', e); } }

        // damage predict
        let damage = {class:'unknown', score:0};
        if(damageModel){ try{ const imgT = tf.browser.fromPixels(crop).resizeBilinear([224,224]).toFloat().expandDims(0).div(255.0); const p = await damageModel.predict(imgT); const parr = p.data ? await p.data() : await p.array(); const midx = parr.indexOf(Math.max(...parr)); damage = {class:`class_${midx}`, score:parr[midx]}; imgT.dispose(); if(p.dispose) p.dispose(); }catch(e){ console.error('damage predict err', e); } }

        // diameter estimation
        const pxToCm = refCm / video.videoWidth; const approxDiameterCm = Math.round(Math.min(wbox,hbox) * pxToCm);
        // sortiment heuristic
        let sortiment = 'unknown'; if(approxDiameterCm >= 24) sortiment = 'palk'; else if(approxDiameterCm >= 10) sortiment = 'peenpalk / lati'; else sortiment = 'paberipuit / küttepuu';
        // volume and price
        const lengthM = (hbox * pxToCm)/100; const dM = approxDiameterCm/100; const volumeM3 = Math.PI/4 * dM*dM * Math.max(0.1, lengthM); let pricePerM3 = 40; const speciesName = (species.class || '').toLowerCase(); if(/pine|mänd|kuusk|spruce|pine/i.test(speciesName)) pricePerM3 = 30; else if(/kask|haab|birch|aspen|oak|tamm/i.test(speciesName)) pricePerM3 = 80; const approxPriceEUR = Math.round(volumeM3 * pricePerM3);

        // draw labels on overlay (both top-left and bottom)
        const label = `${species.class} | ${approxDiameterCm} cm | ${sortiment}`;
        ctx.font = `${Math.max(12, Math.round(overlay.width/60))}px sans-serif`;
        const textW = ctx.measureText(label).width + 8; const textH = parseInt(ctx.font,10) + 6;
        ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(x, y - textH, textW, textH);
        ctx.fillStyle='white'; ctx.fillText(label, x+4, y-4);

        // update last summary
        lastSummary = { sortiment, species: species.class, damage: damage.class, value: approxPriceEUR + ' €' };

        frameResults.push({ sortiment, species: species.class, damage: damage.class, approxDiameterCm, approxPriceEUR });
      }

      // update info panel (use lastSummary)
      outSortiment.textContent = lastSummary.sortiment;
      outSpecies.textContent = lastSummary.species;
      outDamage.textContent = lastSummary.damage;
      outValue.textContent = lastSummary.value;

      // push to textual log in requested format (each regiooni eraldi plokk)
      frameResults.forEach(r=>{
        const lines = [];
        lines.push(`SORTIMENT: ${r.sortiment}`);
        lines.push(`PUULIIK: ${r.species}`);
        lines.push(`KAHJUSTUSED: ${r.damage}`);
        lines.push(`UMBKAUDNE VÄÄRTUS: ${r.approxPriceEUR} €`);
        logTextLines.push(lines.join('
'));
      });

      // show log preview (viimased 20 kirjet)
      const preview = logTextLines.slice(-20).join('

');
      logArea.textContent = preview || 'Log tühi — analüüsid ilmuvad siia.';

      status('Analüüs lõpetatud ja logitud. Kuvatud nii overlay-l kui info-paneelil.');
    }

    async function startLoop(){
      const off = document.createElement('canvas'); const offCtx = off.getContext('2d'); off.width=video.videoWidth; off.height=video.videoHeight; overlay.width=off.width; overlay.height=off.height;
      async function loop(){ if(video.paused || video.ended){ animationId = requestAnimationFrame(loop); return; } offCtx.drawImage(video,0,0,off.width,off.height); const imageData = offCtx.getImageData(0,0,off.width,off.height); const motion = detectMotion(imageData); ctx.clearRect(0,0,overlay.width,overlay.height); if(motion){ status('Liikumine tuvastatud — automaatne analüüs võib toimuda'); ctx.fillStyle='rgba(255,0,0,0.08)'; ctx.fillRect(0,0,overlay.width,overlay.height); } else { status('Kaamera ootab — automaatne tuvastus võib jooksvalt analüüsida vastavalt intervallile.'); } animationId = requestAnimationFrame(loop); }
      loop();
    }

    // eventid
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    camSelect.addEventListener('change', async ()=>{ if(stream) await startCamera(); });

    // init
    (async ()=>{ if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ status('Brauser ei toeta getUserMedia API-d. Kasuta kaasaegset brauserit.'); return; } await listCameras(); for(let i=0;i<camSelect.options.length;i++){ if(/back|rear|environment/i.test(camSelect.options[i].text)) { camSelect.selectedIndex=i; break; } } })();

  </script>
</body>
</html>
